<!DOCTYPE html>
<html lang="es">
<head>
    <title>Rust</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="shower/themes/material/styles/screen-16x10.css">
    <link href="prism/prism.css" rel="stylesheet" />
    <style>
        .slide {
            background-color: #397004;
            color: #eee;
        }

        .slide h2 {
            color: white;
        }
        .slide p.note, .slide pre .comment {
            color: #ddd;
        }

        .slide code {
            padding: 0;
        }

        .slide .shout::after {
            position: absolute;
            top: -300%;
            right: 0;
            bottom: -300%;
            left: 0;
            z-index: -1;
            background: #397004 -webkit-linear-gradient(315deg,#397004 50%,#2f4e31 50%) no-repeat;
            background: #397004 linear-gradient(135deg,#397004 50%,#2f4e31 50%) no-repeat;
            content: '';
        }

        .rust-logo {
            background-color: white;
            background-image: url('pictures/rust-logo-blk.svg');
            background-repeat: no-repeat;
            background-position: center;
            background-size: 100%;
            border-radius: 3px;
            margin: 0 auto;
            width: 200px;
            height: 200px;
        }

        .two-columns ul.column-1 {
            font-size: large;
        }

        .two-columns .column-1 {
            float: left;
            width: 48%;
            font-size: small;
        }
        .two-columns .column-2 {
            float: right;
            width: 48%;
            font-size: small;
        }

        .small {
            font-size: small;
        }
    </style>
</head>
<body class="shower list">
    <header class="caption">
        <h1>Introducción a Rust</h1>
        <p>wadobo.com</p>
    </header>
    <section class="slide" id="cover">
        <h2>Introducción a Rust</h2>
        <p>Daniel García Moreno (@danigm)</p>
        <p>&lt;danigm@wadobo.com&gt;</p>
        <p>http://wadobo.com</p>
        <div class="rust-logo"> </div>
        <img src="pictures/slide-bg.png" alt="" class="cover">
        <!--
            To apply styles to the certain slides
            set slide ID to get needed elements
            -->
        <style>
            #cover h2 {
                margin:30px 0 0;
                color:#FFF;
                text-align:center;
                font-size:70px;
                }
            #cover p {
                margin:10px 0 0;
                text-align:center;
                color:#FFF;
                font-style:italic;
                font-size:20px;
            }
            #cover p a {
                color:#FFF;
            }
        </style>
    </section>

    <section class="slide">
        <h2 class="shout shrink">Qué es Rust</h2>
    </section>

    <section class="slide">
        <h2>Rust</h2>
        <figure>
            <blockquote>
                <p>
                    Rust es un lenguaje de programación de sistemas
                    extremadamente rápido, previene fallas de segmentación
                    y garantiza la seguridad de los hilos de ejecución.
                </p>
            </blockquote>
        </figure>
    </section>

    <section class="slide">
        <pre data-line="3"><code class="language-rust">
// hola.rs
fn main() {
    println!("Hola Mundo!");
}</code></pre>

        <pre class="command-line" data-user="danigm" data-host="wadobo"
        data-output="3"><code class="language-bash">
rustc hola.rs
./hola
Hola Mundo!</code></pre>
    </section>

    <section class="slide">
        <h2>C/C++ No son lenguajes seguros</h2>

        <ul>
            <li>Segmentation fault (acceso a un puntero incorrecto)</li>
            <li>Memory leaks (no free)</li>
            <li>Seguridad en hilos</li>
        </ul>
    </section>

    <section class="slide">
        <h2>Lenguajes Seguros</h2>
        <ul>
            <li>Python</li>
            <li>Java</li>
            <li>JavaScript</li>
        </ul>
        <p>Recolector de basura, no son eficientes</p>
    </section>

    <section class="slide"><h2 class="shout">Por qué Rust</h2></section>
    <section class="slide">
        <ul>
            <li>Software libre y desarrollo libre (github.com/rust-lang)</li>
            <li>Rápido y eficiente (cómo C/C++ o mejor)</li>
            <li>Manejo de memoria seguro (No memory leak)</li>
            <li>Sin máquina virtual, interprete ni recolector de basura (runs everywhere)</li>
            <li>Sin comportamiento no definido</li>
            <li>Abstracción a coste cero</li>
            <li>Sintáxis moderna</li>
            <li>Comunidad</li>
            <li>Sponsored by Mozilla (makers of Firefox)</li>
        </ul>
    </section>

    <section class="slide"><h2 class="shout">rustup y Cargo</h2></section>
    <section class="slide">
        <h2>Instalar y tener actualizado rust es realmente sencillo con rustup</h2>
        <pre class="command-line" data-user="danigm" data-host="wadobo"><code class="language-bash">
curl https://sh.rustup.rs -sSf | sh
export PATH=$PATH:$HOME/.cargo/bin</code></pre>
        Además se pueden instalar otros targets para compilación cruzada
        <pre class="command-line" data-user="danigm" data-host="wadobo"><code class="language-bash">
rustup target list
rustup target install x86_64-pc-windows-gnu</code></pre>
    </section>

    <section class="slide">
        <h2>Cargo</h2>
        Cargo es una herramienta que nos permite gestionar proyectos rust,
        dependencias, compilar, generar documentación, hacer tests, etc...
        <pre class="command-line" data-user="danigm" data-host="wadobo"><code class="language-bash">cargo new --bin hola</code></pre>

        <div class="two-columns">
            <pre class="column-1"><code class="language-config">
# cat Cargo.toml
[package]
name = "hola"
version = "0.1.0"
authors = ["Daniel García Moreno <danigm@wadobo.com>"]

[dependencies] </code> </pre>
            <pre class="column-2"><code class="language-rust">
// cat src/main.rs
fn main() {
    println!("Hello, world!");
} </code> </pre>
        </div>
    </section>

    <section class="slide">
        <pre class="command-line" data-user="danigm" data-host="wadobo" data-output="2"><code class="language-bash">
cargo run
Hello, world!
cargo build --release
cargo check
cargo test
cargo doc
cargo search time
cargo add package
cargo install package
cargo publish</code></pre>
    </section>

    <section class="slide"><h2 class="shout">Sintaxis</h2></section>
    <section class="slide two-columns">
        <pre class="column-1"><code class="language-rust">
extern crate chrono;
use chrono::prelude::*;

fn get_time() -> DateTime<Local> {
    let d = Local::now();
    d
}

/// función que suma los números de 0 a n
fn get_sum(n: i32) -> i32 {
    let mut x: i32 = 0;
    for i in 0..n {
        x += i;
    }

    x
}</code></pre>

        <pre class="column-2"><code class="language-rust">
fn dup(txt1: &str, txt2: &str) {
    println!("{0} {1} {0} {1}", txt1, txt2);
}

// función principal
fn main() {
    let t = get_time();
    println!("Hola Mundo! {}", t);

    let i = get_sum(10);
    println!("Resultado: {}", i);

    dup("esto", "otro");
}</code></pre>
    </section>

    <section class="slide"><h2 class="shout">Structs y Enums</h2></section>
    <section class="slide two-columns">
        <pre class="column-2"><code class="language-rust">
pub struct Persona {
    nombre: String,
    apellido1: String,
    apellido2: Option<String>,
    edad: i32,
    prof: Profesion,
}

impl Persona {
    pub fn new(nombre: String, apellidos: (String, String)) -> Persona {
        Persona {
            nombre: nombre,
            apellido1: apellidos.0,
            apellido2: Some(apellidos.1),
            edad: 0,
            prof: Profesion::Docotor(Profesion::Medicina),
        }
    }
}
</code></pre>

        <pre class="column-1"><code class="language-rust">
enum Profesion {
    Informatica,
    Medicina,
    Doctor(Profesion),
    Estudiante(Profesion),
    Otro(String),
}
</code></pre>
    </section>

    <section class="slide"><h2 class="shout">Gestión de memoria</h2></section>
    <section class="slide two-columns">
        <h2>Ownership</h2>
        <ul class="column-1">
            <li>Las variables son propietarias de la memoria a la que apuntan</li>
            <li>Las asignaciones por defecto "mueven" la propiedad de la memoria</li>
            <li>Los tipos básicos y los tipos que implementan Copy son "copiados" en lugar de "movidos"</li>
            <li>Muchos tipos implementan Clone para poder "copiar" explícitamente</li>
        </ul>

        <pre class="column-2"><code class="language-rust">
let v = vec![1, 2, 3];
let v2 = v;

let a = v[0]; // Error, intentamos usar v después de moverlo
</code></pre>
    </section>
    <section class="slide two-columns">
        <h2>Borrowing</h2>
        <ul class="column-1">
            <li>En lugar de "mover" pasamos una referencia con "&amp;"</li>
            <li>Pueden existir una o más referencias a un valor (&amp;T)</li>
            <li>Sólo puede existir una referencia mutable (&amp;mut T)</li>
            <li>El ámbito de la referencia no puede ser mayor que el del propietario del valor</li>
        </ul>

        <pre class="column-2"><code class="language-rust">
let mut v = vec![1, 2, 3];
let v2 = &v; // referencia
let v3 = &v; // referencia

let a = v[0];

// Error, como hay referencias de lectura, no puede existir una referencia mutable
let v4 = &mut v;
</code></pre>
<pre class="column-2"><code class="language-rust">
let mut n = 3;
{
    let nref = &n;
    *nref = 5;
}

println!("n: {}", n);
</code></pre>

    </section>

    <section class="slide two-columns">
        <h2>Lifetimes</h2>
        <ul class="column-1">
            <li>Las referencias tienen un tiempo de vida asociado al ámbito del valor al que apuntan</li>
            <li>Como una referencia no puede vivir más que el valor al que
            apunta, a veces hay que decirle al compilador cuál es el
            "lifetime"</li>
        </ul>

        <pre class="column-2"><code class="language-rust">
fn eliminar_prefijo<'a, 'b>(orig: &'a str,
                            prefijo: &'b str)
                            -> &'a str {
    &orig[prefijo.len()..]
}

fn main() {
    let x;
    {
        let a = "texto:hola".to_string();
        let b = "texto:";

        x = eliminar_prefijo(&a, &b);
    }

    println!("X: {}", x);
}
</code></pre>
    </section>

    <section class="slide"><h2 class="shout">Gestión de errores</h2></section>
    <section class="slide two-columns">
        <h2>Result&lt;T, E&gt;</h2>
        <ul class="column-1">
            <li>Rust no tiene excepciones</li>
            <li>Existe un tipo llamado Result que se usa para operaciones
            que pueden fallar</li>
            <li>Un Result puede ser Ok(T) o Err(E), es un enum</li>
            <li>El operador "?" se utiliza para propagar errores dentro de
            funciones que devuelven un Result</li>
            <li>Usar el tipo Result nos "obliga" a tratar los errores</li>
        </ul>

        <pre class="column-2"><code class="language-rust">
fn division(n: i32, d: i32) -> Result&lt;i32, &str> {
    if d == 0 {
        return "No se puede dividir por cero";
    }
    n / d
}
fn propagando() -> Result&lt;i32, &str> {
    let n = division(3, 0)?;
    println!("resultado de la división: {}", n);
    n
}
fn main() {
    let r = propagando();
    if r.is_ok() {
        // accediendo al valor, si no es ok, fallará
        println!("valor: {}", r.unwrap());
    }
    assert_eq!(r, Err("No se puede dividir por cero"));
}
</code></pre>
    </section>

    <section class="slide"><h2 class="shout">Option</h2></section>
    <section class="slide two-columns">
        <h2>Option&lt;T&gt;</h2>
        <ul class="column-1">
            <li>Rust no tiene tipo NULL</li>
            <li>Existe un tipo llamado Option que se usa para definir tipos
            que puedan estar "vacíos"</li>
            <li>Un option puede ser Some(T) o None, es un enum</li>
            <li>Usar el tipo Option nos "obliga" a tratar los tipos "nulos"</li>
        </ul>

        <pre class="column-2"><code class="language-rust">
let mut n: Option&lt;i32&gt; = None;

// Error porque es un option, no un i32
let suma = n + 3;
if n.is_some() {
    let suma = n.unwrap() + 3;
}

n = Some(5);
let suma = match n {
    Some(i) => i + 3,
    None => 0,
};
</code></pre>
    </section>

    <section class="slide"><h2 class="shout">Pattern matching</h2></section>
    <section class="slide">
        <h2>Pattern matching</h2>

        <ul>
            <li>Se utiliza como una especie de switch</li>
            <li>Gestión de errores y tipos nulos</li>
            <li>Muy útil combinado con enums</li>
        </ul>
    </section>
    <section class="slide">
        <pre><code class="language-rust">
match n {
    i if i &lt; 0 => {
        println!("número negativo: {}", i);
    },
    5 => println!("n es 5"),
    _ => println!("cualquier cosa"),
};
</code></pre>
    </section>
    <section class="slide">
        <pre><code class="language-rust">
if let Some(n) = funcion_devuelve_option(23) {
    println!("{}", n + 4);
}

if let Err(error) = funcion_result(3, 5) {
    println!("ha ocurrido un error");
    return;
}
</code></pre>
    </section>
    <section class="slide">
        <pre><code class="language-rust">
let n1 = match n {
    i if i &gt; 0 => -i,
    0 => 0,
    _ => 42,
};
</code></pre>
    </section>

    <section class="slide"><h2 class="shout">Traits</h2></section>
    <section class="slide"><h2 class="shout">Macros</h2></section>
    <section class="slide"><h2 class="shout">Crates y módulos</h2></section>
    <section class="slide"><h2 class="shout">Documentación y tests</h2></section>

    <section class="slide" id="see-more">
        <h2 class="shout">
            rust-lang.org
        </h2>
    </section>
    <!--
        To hide progress bar from entire presentation
        just remove “progress” element.
        -->
    <div class="progress"></div>
    <script src="shower/shower.min.js"></script>
    <script src="prism/prism.js"></script>
</body>
</html>
